<plugin>
    <script>
        // Windy API modules are imported via '@windy/nameOfModule'
        import map from '@windy/map';
        const MARKER = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' style='margin:auto;background:rgba(160, 88, 181,0);display:block;' width='200px' height='200px' viewBox='0 0 100 100' preserveAspectRatio='xMidYMid'><circle cx='50' cy='50' r='0' fill='none' stroke='#e90c59' stroke-width='17'>  <animate attributeName='r' repeatCount='indefinite' dur='1s' values='0;26' keyTimes='0;1' keySplines='0 0.2 0.8 1' calcMode='spline' begin='-0.5s'></animate>  <animate attributeName='opacity' repeatCount='indefinite' dur='1s' values='1;0' keyTimes='0;1' keySplines='0.2 0 0.8 1' calcMode='spline' begin='-0.5s'></animate></circle><circle cx='50' cy='50' r='0' fill='none' stroke='#46dff0' stroke-width='17'>  <animate attributeName='r' repeatCount='indefinite' dur='1s' values='0;26' keyTimes='0;1' keySplines='0 0.2 0.8 1' calcMode='spline'></animate>  <animate attributeName='opacity' repeatCount='indefinite' dur='1s' values='1;0' keyTimes='0;1' keySplines='0.2 0 0.8 1' calcMode='spline'></animate></circle></svg>");
        const MARKER_URL = `data:image/svg+xml;utf8,${MARKER}`;
        const Icon = L.icon({
            iconUrl: MARKER_URL,
            iconSize: [48, 48],
            iconAnchor: [24, 24],
            popupAnchor: [0, -50],
        });
        const MARKER_DOT = encodeURIComponent("<svg height='480pt' viewBox='0 0 480 480' width='480pt' xmlns='http://www.w3.org/2000/svg'><path d='m432 240c0 106.039062-85.960938 192-192 192s-192-85.960938-192-192 85.960938-192 192-192 192 85.960938 192 192zm0 0' fill='#cfd2fc'/><path d='m240 480c-132.546875 0-240-107.453125-240-240s107.453125-240 240-240 240 107.453125 240 240c-.148438 132.484375-107.515625 239.851562-240 240zm0-464c-123.710938 0-224 100.289062-224 224s100.289062 224 224 224 224-100.289062 224-224c-.140625-123.652344-100.347656-223.859375-224-224zm0 0' fill='#8690fa'/><path d='m352 240c0 61.855469-50.144531 112-112 112s-112-50.144531-112-112 50.144531-112 112-112 112 50.144531 112 112zm0 0' fill='#5153ff'/></svg>");
        const MARKER_DOT_URL = `data:image/svg+xml;utf8,${MARKER_DOT}`;
        const Icon_Dot = L.icon({
            iconUrl: MARKER_DOT_URL,
            iconSize: [16, 16],
            iconAnchor: [8, 8],
            popupAnchor: [0, 0],
        });
        const MARKER_FCST = encodeURIComponent("<?xml version='1.0' encoding='iso-8859-1'?> <!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --> <svg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='0 0 512 512' style='enable-background:new 0 0 512 512;' xml:space='preserve'> <circle style='fill:#FEE187;' cx='255.995' cy='255.996' r='76.945'/> <g> <path style='fill:#FFC61B;' d='M255.997,347.463c-50.433,0-91.463-41.031-91.463-91.463s41.031-91.463,91.463-91.463 S347.46,205.567,347.46,256S306.429,347.463,255.997,347.463z M255.997,193.573c-34.422,0-62.427,28.005-62.427,62.427 s28.005,62.427,62.427,62.427s62.427-28.005,62.427-62.427S290.419,193.573,255.997,193.573z'/> <path style='fill:#FFC61B;' d='M255.997,512c-68.381,0-132.668-26.629-181.02-74.98c-5.669-5.669-5.669-14.862,0-20.533 c5.671-5.669,14.861-5.669,20.533,0c42.867,42.869,99.863,66.476,160.488,66.476s117.62-23.608,160.488-66.476 c42.867-42.867,66.476-99.863,66.476-160.488s-23.609-117.62-66.476-160.488c-42.869-42.869-99.863-66.476-160.488-66.476 S138.377,52.644,95.509,95.512c-57.256,57.256-79.73,141.45-58.65,219.728c2.085,7.742-2.503,15.708-10.244,17.793 c-7.75,2.088-15.708-2.501-17.795-10.244C-2.68,280.078-2.936,234.853,8.085,192.005c11.355-44.152,34.486-84.618,66.892-117.025 C123.329,26.629,187.616,0,255.997,0s132.668,26.629,181.02,74.98c48.352,48.352,74.98,112.639,74.98,181.02 s-26.629,132.667-74.98,181.02C388.665,485.371,324.377,512,255.997,512z'/> <path style='fill:#FFC61B;' d='M255.997,452.028c-108.091,0-196.028-87.938-196.028-196.028S147.906,59.972,255.997,59.972 c69.932,0,135.071,37.687,169.997,98.355c4.001,6.948,1.61,15.825-5.338,19.826c-6.951,4-15.823,1.609-19.824-5.338 c-29.76-51.693-85.258-83.807-144.834-83.807c-92.08,0-166.992,74.913-166.992,166.992s74.913,166.992,166.992,166.992 S422.989,348.079,422.989,256c0-8.018,6.501-14.518,14.518-14.518s14.518,6.5,14.518,14.518 C452.025,364.091,364.088,452.028,255.997,452.028z'/> </g></svg>");
        const MARKER_FCST_URL = `data:image/svg+xml;utf8,${MARKER_FCST}`;
        const Icon_Fcst = L.icon({
            iconUrl: MARKER_FCST_URL,
            iconSize: [16, 16],
            iconAnchor: [8, 8],
            popupAnchor: [0, 0],
        });
        let disturbance = L.layerGroup();
        const disturbances = {};
        const jtwc = {};
        const ukmet = {};
        const cmrs = {};
        fetch('https://www.meteoi.re/windy.php')
            .then(res => res.json())
            .then((out) => {
                Object.keys(out).forEach(key => {
                    console.log(key);
                    if(key !== "_UKMO"){
                    Object.values(out[key]['track']).forEach(entry => {
                        let name = key;
                        let date = entry["date"];
                        let time = entry["time"];
                        let lat = entry["lat"];
                        let lon = entry["lon"];
                        let wind = entry["wind"];
                        let pressure = entry["pressure"];
                        let wind_kmh = Math.ceil(wind * 1.852);
                        let gust = Math.ceil(wind * 1.35);
                        let gust_kmh = Math.ceil(wind_kmh * 1.35);
                        L.marker({ lat, lon }, { icon: Icon_Dot }).bindPopup("<b>Date/time</b>:" + date + " " + time + "<br><b>Name</b>: " + name + "<br><b>Pressure</b>: " + pressure + " hPa<br><b>Wind(knots)</b>: " + wind + "  | <b>Gusts(knots):</b> " + gust + "<br><b>Wind(km/h)</b>: " + wind_kmh + "  | <b>Gusts(km/h):</b>" + gust_kmh + "<br><small><em>by Meteoi.re</em></small>").addTo(disturbance);
                        if (name in disturbances) {
                            //disturbances[name].push(new Array(name, date, hour, lat, lon, pressure, wind));
                            disturbances[name].push(new Array(parseFloat(lat), parseFloat(lon)));
                        } else {
                            disturbances[name] = [];
                            //disturbances[name].push(new Array(name, date, hour, lat, lon, pressure, wind));
                            disturbances[name].push(new Array(parseFloat(lat), parseFloat(lon)));
                        }
                        let arr = Object.values(disturbances);
                        L.polyline(arr, { color: 'cyan' }).addTo(disturbance);
                        let lata = parseFloat(out[key]['track'][Object.keys(out[key]['track']).pop()]['lat']);
                        let lona = parseFloat(out[key]['track'][Object.keys(out[key]['track']).pop()]['lon']);
                        jtwc[key] = [];
                        jtwc[key].push(new Array(parseFloat(lata), parseFloat(lona)));
                        L.marker([lata, lona], { icon: Icon }).bindPopup("<b>Date/time</b>:" + date + " " + time + "<br><b>Name</b>: " + name + "<br><b>Pressure</b>: " + pressure + " hPa<br><b>Wind(knots)</b>: " + wind + "  | <b>Gusts(knots):</b> " + gust + "<br><b>Wind(km/h)</b>: " + wind_kmh + "  | <b>Gusts(km/h):</b>" + gust_kmh + "<br><small><em>by Meteoi.re</em></small>").addTo(disturbance);
                        let namea = key;
                        L.marker([lata, lona], {
                            icon: new L.DivIcon({
                                className: 'my-div-icon',
                                html: '' + namea + '',
                                iconAnchor: [100, 0],
                            })
                        }).addTo(disturbance);
                    });
                    //
                    // JTWC JTWC
                    //
                    if (out[key].hasOwnProperty('forecast')) {
                        if(out[key]['forecast'].hasOwnProperty('JTWC')){
                        Object.values(out[key]['forecast']['JTWC']).forEach(entry => {
                            let name_Jtwc = key;
                            let date_origin = new Date();
                            let month = date_origin.getMonth() + 1;
                            let date_Jtwc = entry["date"] + "/" + month + "/" + date_origin.getFullYear();
                            let time_Jtwc = entry["time"];
                            let lat_Jtwc = entry["lat"];
                            let lon_Jtwc = entry["lon"];
                            let wind_Jtwc = entry["wind"];
                            let gust_Jtwc = entry["gust"];
                            let wind_kmh_Jtwc = Math.ceil(wind_Jtwc * 1.852);
                            let gust_kmh_Jtwc = Math.ceil(gust_Jtwc * 1.852);
                            let color ;
                            if (wind_Jtwc >= 130) {
                                color = "black";
                              } else if (wind_Jtwc >= 100){
                                color = "purple";
                              } else if (wind_Jtwc >= 75){
                                color = "red";
                              } else if (wind_Jtwc >= 50){
                                color = "orange";
                              } else {
                                color = "yellow";
                              }
                            L.circle([lat_Jtwc, lon_Jtwc], { color: color, fillColor: color, fillOpacity: 0.4, radius: 20000 }).bindPopup("<u>JTWC FORECAST</u><br><b>Date/time</b>:" + date_Jtwc + " " + time_Jtwc + "<br><b>Name</b>: " + name_Jtwc + " <br><b>Wind(knots)</b>: " + wind_Jtwc + "  | <b>Gusts(knots):</b> " + gust_Jtwc + "<br><b>Wind(km/h)</b>: " + wind_kmh_Jtwc + "  | <b>Gusts(km/h):</b>" + gust_kmh_Jtwc + "<br><small><em>by Meteoi.re</em></small>").addTo(disturbance);
                            if (name_Jtwc in jtwc) {
                                jtwc[name_Jtwc].push(new Array(parseFloat(lat_Jtwc), parseFloat(lon_Jtwc)));
                            } else {
                                jtwc[name_Jtwc] = [];
                                jtwc[name_Jtwc].push(new Array(parseFloat(lat_Jtwc), parseFloat(lon_Jtwc)));
                            }
                            let arr_jtwc = Object.values(jtwc);
                            L.polyline(arr_jtwc, { color: 'white', dashArray: '5, 5', dashOffset: '0' }).addTo(disturbance);
                        });
                    }
                    }

                    // UKMET
                    
                    if (out[key].hasOwnProperty('forecast')) {
                        if(out[key]['forecast'].hasOwnProperty('UKMET')){
                        Object.values(out[key]['forecast']['UKMET']).forEach(entry => {
                            let name_UKMET = key;
                            let date_origin = new Date();
                            let month = date_origin.getMonth() + 1;
                            let date_UKMET = entry["date"];
                            let time_UKMET = entry["time"];
                            let lat_UKMET = entry["lat"];
                            let lon_UKMET = entry["lon"];
                            let wind_UKMET = entry["wind"];
                            let pressure_UKMET = entry["pressure"];
                            let wind_kmh_UKMET = Math.ceil(wind_UKMET * 1.852);
                            let color ;
                            if (wind_UKMET >= 130) {
                                color = "black";
                              } else if (wind_UKMET >= 100){
                                color = "purple";
                              } else if (wind_UKMET >= 75){
                                color = "red";
                              } else if (wind_UKMET >= 50){
                                color = "orange";
                              } else {
                                color = "yellow";
                              }
                            L.circle([lat_UKMET, lon_UKMET], { color: color, fillColor: color, fillOpacity: 0.4, radius: 20000 }).bindPopup("<u>UKMET FORECAST</u><br><b>Date/time</b>:" + date_UKMET + " " + time_UKMET + "<br><b>Name</b>: " + name_UKMET + " <br><b>Wind(knots)</b>: " + wind_UKMET + "  <br> <b>Pressure (mb):</b> " + pressure_UKMET +"<br><small><em>by Meteoi.re</em></small>").addTo(disturbance);
                            if (name_UKMET in ukmet) {
                                ukmet[name_UKMET].push(new Array(parseFloat(lat_UKMET), parseFloat(lon_UKMET)));
                            } else {
                                ukmet[name_UKMET] = [];
                                ukmet[name_UKMET].push(new Array(parseFloat(lat_UKMET), parseFloat(lon_UKMET)));
                            }
                            let arr_UKMET = Object.values(ukmet);
                            L.polyline(arr_UKMET, { color: 'yellow', dashArray: '5, 5', dashOffset: '0' }).addTo(disturbance);
                        });
                    }
                }

                    // CMRS

                    if (out[key].hasOwnProperty('forecast')) {
                        if(out[key]['forecast'].hasOwnProperty('CMRS')){
                        Object.values(out[key]['forecast']['CMRS']).forEach(entry => {
                            let name_CMRS = key;
                            let date_origin = new Date();
                            let month = date_origin.getMonth() + 1;
                            let date_CMRS = entry["date"];
                            let time_CMRS = entry["time"];
                            let lat_CMRS = entry["lat"];
                            let lon_CMRS = entry["lon"];
                            let wind_CMRS = entry["wind"];
                            let pressure_CMRS = entry["pressure"];
                            let wind_kmh_CMRS = Math.ceil(wind_CMRS * 1.852);
                            let color ;
                            if (wind_CMRS >= 130) {
                                color = "black";
                              } else if (wind_CMRS >= 100){
                                color = "purple";
                              } else if (wind_CMRS >= 75){
                                color = "red";
                              } else if (wind_CMRS >= 50){
                                color = "orange";
                              } else {
                                color = "yellow";
                              }
                            L.circle([lat_CMRS, lon_CMRS], { color: color, fillColor: color, fillOpacity: 0.4, radius: 20000 }).bindPopup("<u>CMRS FORECAST</u><br><b>Date/time</b>:" + date_CMRS + " " + time_CMRS + "<br><b>Name</b>: " + name_CMRS + " <br><b>Wind(knots)</b>: " + wind_CMRS + "<br><small><em>by Meteoi.re</em></small>").addTo(disturbance);
                            if (name_CMRS in cmrs) {
                                cmrs[name_CMRS].push(new Array(parseFloat(lat_CMRS), parseFloat(lon_CMRS)));
                            } else {
                                cmrs[name_CMRS] = [];
                                cmrs[name_CMRS].push(new Array(parseFloat(lat_CMRS), parseFloat(lon_CMRS)));
                            }
                            let arr_CMRS = Object.values(cmrs);
                            L.polyline(arr_CMRS, { color: 'red', dashArray: '5, 5', dashOffset: '0' }).addTo(disturbance);
                        });
                    }
                    }
                    else {
                        if('_UKMO' in out){
                            Object.values(out['_UKMO']).forEach(entry => {
                                let color_uk
                                if(entry["intensity"] == 'CYCLONE'){
                                    color_uk = 'red';
                                } else {
                                    color_uk = 'yellow';
                                }
                                L.circle([entry["lat"], entry["lon"]], { color: color_uk, fillColor: color_uk, fillOpacity: 0.4, radius: 300000,weight: 0.7 }).bindPopup("<u>UKMET FORECAST</u><br><b>"+entry["intensity"]+" expected to develop in: +" + entry["time"] + " hours</b><br><small><em>by Meteoi.re</em></small>").addTo(disturbance);
                            });
                        }
                    }
                }
                });
            
            }).catch(err => console.error(err));

        this.onopen = () => {
            disturbance.addTo(map);
        }

        this.onclose = () => {
            map.removeLayer(disturbance);
        }
    </script>
</plugin>
